// =====================================================
// APPROVAL GATEWAY - 2FA dual-channel skill approval
// Uses Twilio (SMS) + email for multi-channel confirmation
// =====================================================

import { createClient } from "@supabase/supabase-js";
import twilio from "twilio";
import { GeneratedSkill, SkillApprovalRequest } from "../types";
import { logger } from "@/lib/logger";
import {
  generateDisclosure,
  formatDisclosureForSms,
  formatDisclosureForEmail,
} from "./disclosure-generator";
import { invalidateDynamicToolCache } from "@/lib/iors/tools/dynamic-handler";

function getServiceSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
  );
}

function getTwilioClient() {
  return twilio(
    process.env.TWILIO_ACCOUNT_SID!,
    process.env.TWILIO_AUTH_TOKEN!,
  );
}

/**
 * Initiate the approval flow for a generated skill.
 * Creates an approval request and sends notification via channel 1 (SMS).
 */
export async function initiateApproval(
  skill: GeneratedSkill,
): Promise<{ success: boolean; approvalRequestId?: string; error?: string }> {
  try {
    const supabase = getServiceSupabase();

    // Get tenant phone number
    const { data: tenant, error: tenantError } = await supabase
      .from("exo_tenants")
      .select("phone, email, name")
      .eq("id", skill.tenant_id)
      .single();

    if (tenantError || !tenant) {
      return { success: false, error: "Tenant not found" };
    }

    // Determine if 2FA is needed based on risk level
    const requires2fa = skill.risk_level === "high";

    // Determine channels
    const channel1 = tenant.phone ? "sms" : "email";
    const channel2 = requires2fa
      ? channel1 === "sms"
        ? "email"
        : "sms"
      : null;

    // Generate disclosure
    const disclosure = generateDisclosure(skill);

    // Create approval request (confirmation code generated by DB function)
    const { data: approvalRequest, error: insertError } = await supabase
      .from("exo_skill_approval_requests")
      .insert({
        tenant_id: skill.tenant_id,
        skill_id: skill.id,
        request_reason: skill.generation_prompt || "user_request",
        capability_disclosure: disclosure.details,
        requires_2fa: requires2fa,
        channel_1: channel1,
        channel_2: channel2,
        confirmation_code: generateConfirmationCode(),
      })
      .select()
      .single();

    if (insertError || !approvalRequest) {
      logger.error(
        "[ApprovalGateway] Failed to create approval request:",
        insertError,
      );
      return {
        success: false,
        error: insertError?.message || "Failed to create approval request",
      };
    }

    // Send notification via channel 1
    const sendResult = await sendApprovalNotification(
      approvalRequest as SkillApprovalRequest,
      disclosure,
      tenant,
    );

    if (!sendResult.success) {
      logger.error(
        "[ApprovalGateway] Failed to send notification:",
        sendResult.error,
      );
      // Don't fail the whole flow - user can still see it in the UI
    }

    // Update notification sent timestamp
    await supabase
      .from("exo_skill_approval_requests")
      .update({ notification_sent_at: new Date().toISOString() })
      .eq("id", approvalRequest.id);

    return {
      success: true,
      approvalRequestId: approvalRequest.id,
    };
  } catch (error) {
    logger.error("[ApprovalGateway] Error initiating approval:", error);
    return { success: false, error: (error as Error).message };
  }
}

/**
 * Confirm a channel (submit confirmation code).
 * For single-channel (low/medium risk): approves immediately.
 * For 2FA (high risk): moves to channel_1_confirmed, then needs channel 2.
 */
export async function confirmChannel(
  approvalRequestId: string,
  code: string,
  channel: "sms" | "email",
): Promise<{
  status:
    | "channel_1_confirmed"
    | "approved"
    | "rejected"
    | "invalid_code"
    | "expired";
  error?: string;
}> {
  try {
    const supabase = getServiceSupabase();

    // Load the approval request
    const { data: request, error: loadError } = await supabase
      .from("exo_skill_approval_requests")
      .select("*")
      .eq("id", approvalRequestId)
      .single();

    if (loadError || !request) {
      return { status: "invalid_code", error: "Approval request not found" };
    }

    // Check expiration
    if (new Date(request.expires_at) < new Date()) {
      await supabase
        .from("exo_skill_approval_requests")
        .update({ status: "expired" })
        .eq("id", approvalRequestId);
      return { status: "expired", error: "Approval request has expired" };
    }

    // Check code matches
    if (request.confirmation_code !== code.toUpperCase().trim()) {
      return { status: "invalid_code", error: "Invalid confirmation code" };
    }

    // Check if already fully approved
    if (request.status === "approved") {
      return { status: "approved" };
    }

    // Determine which channel is being confirmed
    if (request.status === "pending") {
      // First channel confirmation
      if (!request.requires_2fa) {
        // Single channel - approve immediately
        await supabase
          .from("exo_skill_approval_requests")
          .update({
            status: "approved",
            channel_1_confirmed_at: new Date().toISOString(),
            responded_at: new Date().toISOString(),
          })
          .eq("id", approvalRequestId);

        // Activate the skill
        await activateSkill(request.skill_id);

        return { status: "approved" };
      } else {
        // 2FA - move to channel_1_confirmed
        await supabase
          .from("exo_skill_approval_requests")
          .update({
            status: "channel_1_confirmed",
            channel_1_confirmed_at: new Date().toISOString(),
          })
          .eq("id", approvalRequestId);

        // Send notification to channel 2
        const { data: tenantData } = await supabase
          .from("exo_tenants")
          .select("phone, email, name")
          .eq("id", request.tenant_id)
          .single();

        if (tenantData) {
          const ch2Result = await sendChannel2Notification(request, tenantData);
          if (!ch2Result.success) {
            logger.warn(
              "[ApprovalGateway] Channel 2 notification failed:",
              ch2Result.error,
            );
          }
        }

        return { status: "channel_1_confirmed" };
      }
    }

    if (request.status === "channel_1_confirmed") {
      // Second channel confirmation (2FA)
      // Verify it's a different channel
      if (channel === request.channel_1) {
        return {
          status: "invalid_code",
          error: "Must confirm from a different channel",
        };
      }

      await supabase
        .from("exo_skill_approval_requests")
        .update({
          status: "approved",
          channel_2_confirmed_at: new Date().toISOString(),
          responded_at: new Date().toISOString(),
        })
        .eq("id", approvalRequestId);

      // Activate the skill
      await activateSkill(request.skill_id);

      return { status: "approved" };
    }

    return {
      status: "invalid_code",
      error: `Unexpected request status: ${request.status}`,
    };
  } catch (error) {
    logger.error("[ApprovalGateway] Error confirming channel:", error);
    return { status: "invalid_code", error: (error as Error).message };
  }
}

/**
 * Reject a skill approval request
 */
export async function rejectApproval(
  approvalRequestId: string,
  reason?: string,
): Promise<{ success: boolean }> {
  try {
    const supabase = getServiceSupabase();

    await supabase
      .from("exo_skill_approval_requests")
      .update({
        status: "rejected",
        responded_at: new Date().toISOString(),
      })
      .eq("id", approvalRequestId);

    // Update skill status
    const { data: request } = await supabase
      .from("exo_skill_approval_requests")
      .select("skill_id")
      .eq("id", approvalRequestId)
      .single();

    if (request) {
      await supabase
        .from("exo_generated_skills")
        .update({
          approval_status: "rejected",
          rejection_reason: reason || "User rejected",
        })
        .eq("id", request.skill_id);
    }

    return { success: true };
  } catch (error) {
    logger.error("[ApprovalGateway] Error rejecting:", error);
    return { success: false };
  }
}

// =====================================================
// Internal helpers
// =====================================================

/**
 * Activate a skill by setting approval_status to 'approved'
 */
async function activateSkill(skillId: string): Promise<void> {
  const supabase = getServiceSupabase();
  await supabase
    .from("exo_generated_skills")
    .update({
      approval_status: "approved",
      approved_at: new Date().toISOString(),
      approved_by: "user",
    })
    .eq("id", skillId);

  // Register approved skill as a dynamic tool so it's callable via chat
  try {
    const { data: skill } = await supabase
      .from("exo_generated_skills")
      .select("name, description, input_schema, tenant_id")
      .eq("id", skillId)
      .single();

    if (skill) {
      const toolName = skill.name
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "_")
        .replace(/^_|_$/g, "")
        .slice(0, 50);

      await supabase.from("exo_dynamic_tools").upsert(
        {
          tenant_id: skill.tenant_id,
          name: toolName,
          description: skill.description || `Skill: ${skill.name}`,
          input_schema: skill.input_schema || {
            type: "object",
            properties: {
              action: { type: "string", description: "Action to execute" },
              params: { type: "object", description: "Action parameters" },
            },
            required: ["action"],
          },
          handler_type: "skill_exec",
          handler_config: { skill_id: skillId },
          enabled: true,
        },
        { onConflict: "tenant_id,name" },
      );

      invalidateDynamicToolCache(skill.tenant_id);
      logger.info(
        `[ApprovalGateway] Skill ${skillId} registered as dynamic tool: dyn_${toolName}`,
      );
    }
  } catch (regErr) {
    // Non-fatal: skill is approved but tool registration failed
    logger.error(
      `[ApprovalGateway] Failed to register skill ${skillId} as dynamic tool:`,
      regErr,
    );
  }

  logger.info(`[ApprovalGateway] Skill ${skillId} activated`);
}

/**
 * Send approval notification via the appropriate channel
 */
async function sendApprovalNotification(
  request: SkillApprovalRequest,
  disclosure: { summary: string; details: Record<string, unknown> },
  tenant: { phone?: string; email?: string; name?: string },
): Promise<{ success: boolean; error?: string }> {
  if (request.channel_1 === "sms" && tenant.phone) {
    return sendSmNotification(
      tenant.phone,
      disclosure,
      request.confirmation_code,
    );
  }

  // Fallback: log it (email integration can be added later)
  logger.info(
    "[ApprovalGateway] Approval pending for code:",
    request.confirmation_code,
  );
  return { success: true };
}

/**
 * Send SMS notification via Twilio
 */
async function sendSmNotification(
  phone: string,
  disclosure: { summary: string },
  code: string,
): Promise<{ success: boolean; error?: string }> {
  try {
    const client = getTwilioClient();
    const body = formatDisclosureForSms(disclosure, code);

    await client.messages.create({
      to: phone,
      from: process.env.TWILIO_PHONE_NUMBER!,
      body,
    });

    return { success: true };
  } catch (error) {
    logger.error("[ApprovalGateway] SMS send error:", error);
    return { success: false, error: (error as Error).message };
  }
}

/**
 * Send notification via channel 2 (the channel different from channel 1)
 */
async function sendChannel2Notification(
  request: SkillApprovalRequest,
  tenant: { phone?: string; email?: string; name?: string },
): Promise<{ success: boolean; error?: string }> {
  const channel2 = request.channel_2;

  if (channel2 === "sms" && tenant.phone) {
    return sendSmNotification(
      tenant.phone,
      { summary: `Potwierdz skill (krok 2/2)` },
      request.confirmation_code,
    );
  }

  if (channel2 === "email" && tenant.email) {
    try {
      const supabase = getServiceSupabase();
      const { subject, body } = formatDisclosureForEmail(
        {
          name: "Skill",
          description: "",
          version: "1.0",
          generated_by: "ai",
        } as GeneratedSkill,
        { summary: `Potwierdz skill (krok 2/2)`, details: {} },
        request.confirmation_code,
      );

      await supabase.from("exo_notifications").insert({
        tenant_id: request.tenant_id,
        channel: "email",
        subject,
        body,
        status: "pending",
      });

      logger.info(
        `[ApprovalGateway] Channel 2 email notification queued for ${tenant.email}`,
      );
      return { success: true };
    } catch (error) {
      logger.error("[ApprovalGateway] Channel 2 email error:", error);
      return { success: false, error: (error as Error).message };
    }
  }

  logger.warn(
    `[ApprovalGateway] No delivery method for channel 2: ${channel2}`,
  );
  return { success: false, error: `Cannot deliver to channel: ${channel2}` };
}

/**
 * Generate a 6-character confirmation code (matching DB function pattern)
 */
function generateConfirmationCode(): string {
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  let result = "";
  for (let i = 0; i < 6; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}
