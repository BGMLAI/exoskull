<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IORS Widget - Full Emotion Comparison</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .iors-widget {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .widget-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .widget-header h1 {
            font-size: 28px;
            color: #1a1a1a;
            margin-bottom: 10px;
        }

        .widget-header p {
            color: #666;
            font-size: 14px;
        }

        /* Voice control button */
        .voice-control {
            text-align: center;
            margin: 30px 0;
        }

        .iors-voice-button {
            position: relative;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: #E31E24;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .iors-voice-button:hover {
            background: #c41a1f;
            transform: scale(1.05);
        }

        .iors-voice-button.active {
            background: #1a1a1a;
            animation: pulse 2s infinite;
        }

        .iors-voice-button::after {
            content: '';
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 50%;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .iors-status {
            margin-top: 15px;
            text-align: center;
            color: #333;
            font-size: 16px;
            font-weight: 500;
            letter-spacing: 1px;
        }

        .iors-status.active {
            color: #E31E24;
        }

        /* Emotion comparison grid */
        .emotion-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .emotion-card {
            background: #f9f9f9;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid transparent;
            transition: border-color 0.3s ease;
        }

        .emotion-card.active {
            border-color: #E31E24;
        }

        .emotion-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .emotion-card-title {
            font-size: 14px;
            font-weight: 700;
            color: #1a1a1a;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .emotion-card-badge {
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
        }

        .badge-free {
            background: #4CAF50;
            color: white;
        }

        .badge-paid {
            background: #FF9800;
            color: white;
        }

        .emotion-display {
            text-align: center;
            padding: 20px 0;
        }

        .emotion-emoji {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .emotion-name {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .emotion-confidence {
            font-size: 14px;
            color: #999;
        }

        .emotion-details {
            margin-top: 15px;
            font-size: 12px;
            color: #666;
        }

        .emotion-details-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }

        .emotion-details-label {
            font-weight: 600;
        }

        .emotion-details-value {
            color: #999;
        }

        /* Loading state */
        .loading {
            text-align: center;
            color: #999;
            font-size: 14px;
            padding: 30px;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #E31E24;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Hidden video */
        #iorsFaceVideo {
            display: none;
        }

        /* Debug canvas */
        #debugCanvas {
            display: none;
            max-width: 100%;
            border-radius: 8px;
            margin-top: 20px;
        }

        .debug-section {
            margin-top: 30px;
            text-align: center;
        }

        .debug-toggle {
            padding: 8px 16px;
            background: #666;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }

        .debug-toggle:hover {
            background: #555;
        }

        /* Comparison stats */
        .comparison-stats {
            margin-top: 30px;
            padding: 20px;
            background: #f0f0f0;
            border-radius: 8px;
        }

        .comparison-stats h3 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #333;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }

        .stat-label {
            font-weight: 600;
        }

        .stat-value {
            color: #666;
        }

        @media (max-width: 768px) {
            .emotion-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="iors-widget">
        <div class="widget-header">
            <h1>üé≠ IORS Emotion Detection</h1>
            <p>Por√≥wnanie 3 system√≥w: Face-api.js (FREE) vs Hume AI Face vs Hume AI Voice</p>
        </div>

        <div class="voice-control">
            <button class="iors-voice-button" id="iorsVoiceButton"></button>
            <div class="iors-status" id="iorsStatus">Kliknij aby rozpoczƒÖƒá</div>
        </div>

        <div class="emotion-grid">
            <!-- Face-api.js (FREE) -->
            <div class="emotion-card" id="faceApiCard">
                <div class="emotion-card-header">
                    <span class="emotion-card-title">Face-api.js</span>
                    <span class="emotion-card-badge badge-free">FREE</span>
                </div>
                <div class="emotion-display" id="faceApiDisplay">
                    <div class="loading">
                        <div class="spinner"></div>
                        ≈Åadowanie modeli...
                    </div>
                </div>
            </div>

            <!-- Hume AI Face -->
            <div class="emotion-card" id="humeFaceCard">
                <div class="emotion-card-header">
                    <span class="emotion-card-title">Hume AI Face</span>
                    <span class="emotion-card-badge badge-paid">PAID</span>
                </div>
                <div class="emotion-display" id="humeFaceDisplay">
                    <div class="loading">
                        <div class="spinner"></div>
                        ≈ÅƒÖczenie z API...
                    </div>
                </div>
            </div>

            <!-- Hume AI Voice -->
            <div class="emotion-card" id="humeVoiceCard">
                <div class="emotion-card-header">
                    <span class="emotion-card-title">Hume AI Voice</span>
                    <span class="emotion-card-badge badge-paid">PAID</span>
                </div>
                <div class="emotion-display" id="humeVoiceDisplay">
                    <div class="loading">
                        Czekam na rozmowƒô...
                    </div>
                </div>
            </div>
        </div>

        <div class="comparison-stats" id="comparisonStats" style="display: none;">
            <h3>üìä Statystyki por√≥wnania</h3>
            <div class="stat-row">
                <span class="stat-label">Zgodno≈õƒá Face-api vs Hume Face:</span>
                <span class="stat-value" id="statFaceMatch">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Zgodno≈õƒá Voice vs Face (Hume):</span>
                <span class="stat-value" id="statVoiceFace">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Najsilniejsza emocja (consensus):</span>
                <span class="stat-value" id="statConsensus">-</span>
            </div>
        </div>

        <div class="debug-section">
            <button class="debug-toggle" id="debugToggle">üîç Poka≈º kamerƒô (debug)</button>
            <canvas id="debugCanvas" width="320" height="240"></canvas>
        </div>

        <video id="iorsFaceVideo" autoplay playsinline></video>
    </div>

    <!-- CDN Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@vapi-ai/web@2.1.0/dist/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

    <script>
        // ============================================
        // KONFIGURACJA
        // ============================================
        const IORS_CONFIG = {
            vapiPublicKey: '4b5abdd4-333f-4914-9549-0fe6576ad301',
            assistantId: '747ba1d5-42ac-4f9d-9974-a3f7cd8484ac', // IORS Master

            // Hume AI API Key (potrzebujesz za≈Ço≈ºyƒá konto na hume.ai)
            humeApiKey: 'YOUR_HUME_API_KEY_HERE', // Zamie≈Ñ na sw√≥j klucz

            enableFaceApi: true,      // Face-api.js (FREE)
            enableHumeFace: false,     // Hume AI Face (PAID) - ustaw true gdy masz API key
            enableHumeVoice: false,    // Hume AI Voice (PAID) - ustaw true gdy masz API key

            detectionInterval: 1000   // Check emotions every 1 second
        };

        // Emotion emoji mapping
        const EMOTION_EMOJIS = {
            // Face-api.js emotions
            happy: 'üòä',
            sad: 'üò¢',
            angry: 'üò†',
            disgusted: 'ü§¢',
            fearful: 'üò®',
            surprised: 'üò≤',
            neutral: 'üòê',

            // Hume AI emotions (48 total, pokazujƒô najwa≈ºniejsze)
            joy: 'üòÑ',
            sadness: 'üò¢',
            anger: 'üò°',
            fear: 'üò∞',
            surprise: 'üò≤',
            disgust: 'ü§Æ',
            contempt: 'üòí',
            excitement: 'ü§©',
            amusement: 'üòÜ',
            contentment: 'üòå',
            anxiety: 'üòü',
            embarrassment: 'üò≥',
            pride: 'üò§',
            relief: 'üòÆ‚Äçüí®',
            love: 'ü•∞',
            confusion: 'üòï',
            determination: 'üò§',
            interest: 'ü§î'
        };

        // ============================================
        // FACE-API.JS DETECTOR (FREE)
        // ============================================
        class FaceApiDetector {
            constructor(video) {
                this.video = video;
                this.isReady = false;
                this.currentEmotion = null;
            }

            async init() {
                try {
                    console.log('üé≠ Loading Face-api.js models...');
                    const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.12/model';

                    await Promise.all([
                        faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                        faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL)
                    ]);

                    this.isReady = true;
                    console.log('‚úÖ Face-api.js ready');
                    return true;
                } catch (error) {
                    console.error('‚ùå Face-api.js failed:', error);
                    return false;
                }
            }

            async detect() {
                if (!this.isReady || this.video.readyState !== 4) return null;

                try {
                    const detection = await faceapi
                        .detectSingleFace(this.video, new faceapi.TinyFaceDetectorOptions())
                        .withFaceExpressions();

                    if (detection) {
                        const expressions = detection.expressions;
                        let maxEmotion = 'neutral';
                        let maxScore = 0;

                        for (const [emotion, score] of Object.entries(expressions)) {
                            if (score > maxScore) {
                                maxScore = score;
                                maxEmotion = emotion;
                            }
                        }

                        if (maxScore > 0.5) {
                            this.currentEmotion = {
                                source: 'face-api',
                                emotion: maxEmotion,
                                confidence: maxScore,
                                all: expressions
                            };
                            return this.currentEmotion;
                        }
                    }
                } catch (error) {
                    // Silently fail
                }
                return null;
            }
        }

        // ============================================
        // HUME AI DETECTOR
        // ============================================
        class HumeAIDetector {
            constructor(apiKey) {
                this.apiKey = apiKey;
                this.wsVoice = null;
                this.wsFace = null;
                this.currentVoiceEmotion = null;
                this.currentFaceEmotion = null;
            }

            async connectVoice() {
                if (!this.apiKey || this.apiKey === 'YOUR_HUME_API_KEY_HERE') {
                    console.warn('‚ö†Ô∏è Hume AI Voice: Brak API key');
                    return false;
                }

                try {
                    console.log('üé§ Connecting to Hume AI Voice...');

                    // Hume AI WebSocket endpoint
                    this.wsVoice = new WebSocket('wss://api.hume.ai/v0/stream/models');

                    this.wsVoice.onopen = () => {
                        console.log('‚úÖ Hume AI Voice connected');
                        this.wsVoice.send(JSON.stringify({
                            api_key: this.apiKey,
                            models: {
                                prosody: {}
                            }
                        }));
                    };

                    this.wsVoice.onmessage = (event) => {
                        const data = JSON.parse(event.data);

                        if (data.prosody && data.prosody.predictions) {
                            const predictions = data.prosody.predictions[0];
                            if (predictions && predictions.emotions) {
                                const emotions = predictions.emotions;

                                // Znajd≈∫ top emotion
                                const topEmotion = emotions.reduce((max, e) =>
                                    e.score > max.score ? e : max
                                );

                                this.currentVoiceEmotion = {
                                    source: 'hume-voice',
                                    emotion: topEmotion.name,
                                    confidence: topEmotion.score,
                                    all: emotions.slice(0, 5) // Top 5
                                };

                                this.onVoiceEmotion(this.currentVoiceEmotion);
                            }
                        }
                    };

                    this.wsVoice.onerror = (error) => {
                        console.error('‚ùå Hume AI Voice error:', error);
                    };

                    return true;
                } catch (error) {
                    console.error('‚ùå Hume AI Voice failed:', error);
                    return false;
                }
            }

            async connectFace() {
                if (!this.apiKey || this.apiKey === 'YOUR_HUME_API_KEY_HERE') {
                    console.warn('‚ö†Ô∏è Hume AI Face: Brak API key');
                    return false;
                }

                try {
                    console.log('üë§ Connecting to Hume AI Face...');

                    this.wsFace = new WebSocket('wss://api.hume.ai/v0/stream/models');

                    this.wsFace.onopen = () => {
                        console.log('‚úÖ Hume AI Face connected');
                        this.wsFace.send(JSON.stringify({
                            api_key: this.apiKey,
                            models: {
                                face: {}
                            }
                        }));
                    };

                    this.wsFace.onmessage = (event) => {
                        const data = JSON.parse(event.data);

                        if (data.face && data.face.predictions) {
                            const predictions = data.face.predictions[0];
                            if (predictions && predictions.emotions) {
                                const emotions = predictions.emotions;

                                const topEmotion = emotions.reduce((max, e) =>
                                    e.score > max.score ? e : max
                                );

                                this.currentFaceEmotion = {
                                    source: 'hume-face',
                                    emotion: topEmotion.name,
                                    confidence: topEmotion.score,
                                    all: emotions.slice(0, 5)
                                };

                                this.onFaceEmotion(this.currentFaceEmotion);
                            }
                        }
                    };

                    return true;
                } catch (error) {
                    console.error('‚ùå Hume AI Face failed:', error);
                    return false;
                }
            }

            sendAudio(audioData) {
                if (this.wsVoice && this.wsVoice.readyState === WebSocket.OPEN) {
                    this.wsVoice.send(JSON.stringify({
                        data: audioData,
                        models: { prosody: {} }
                    }));
                }
            }

            sendFrame(frameData) {
                if (this.wsFace && this.wsFace.readyState === WebSocket.OPEN) {
                    this.wsFace.send(JSON.stringify({
                        data: frameData,
                        models: { face: {} }
                    }));
                }
            }

            onVoiceEmotion(callback) {
                this._voiceCallback = callback;
            }

            onFaceEmotion(callback) {
                this._faceCallback = callback;
            }

            disconnect() {
                if (this.wsVoice) this.wsVoice.close();
                if (this.wsFace) this.wsFace.close();
            }
        }

        // ============================================
        // MAIN WIDGET
        // ============================================
        class IORSEmotionWidget {
            constructor(config) {
                this.config = config;
                this.vapiInstance = null;
                this.faceApiDetector = null;
                this.humeDetector = null;

                this.elements = {
                    button: document.getElementById('iorsVoiceButton'),
                    status: document.getElementById('iorsStatus'),
                    faceApiDisplay: document.getElementById('faceApiDisplay'),
                    humeFaceDisplay: document.getElementById('humeFaceDisplay'),
                    humeVoiceDisplay: document.getElementById('humeVoiceDisplay'),
                    faceApiCard: document.getElementById('faceApiCard'),
                    humeFaceCard: document.getElementById('humeFaceCard'),
                    humeVoiceCard: document.getElementById('humeVoiceCard'),
                    video: document.getElementById('iorsFaceVideo'),
                    debugCanvas: document.getElementById('debugCanvas'),
                    debugToggle: document.getElementById('debugToggle'),
                    comparisonStats: document.getElementById('comparisonStats')
                };

                this.emotions = {
                    faceApi: null,
                    humeFace: null,
                    humeVoice: null
                };

                this.init();
            }

            async init() {
                // Camera
                await this.initCamera();

                // Face-api.js
                if (this.config.enableFaceApi) {
                    this.faceApiDetector = new FaceApiDetector(this.elements.video);
                    await this.faceApiDetector.init();
                    this.startFaceApiDetection();
                }

                // Hume AI
                if (this.config.enableHumeFace || this.config.enableHumeVoice) {
                    this.humeDetector = new HumeAIDetector(this.config.humeApiKey);

                    if (this.config.enableHumeFace) {
                        await this.humeDetector.connectFace();
                        this.humeDetector.onFaceEmotion = (emotion) => {
                            this.updateEmotionDisplay('humeFace', emotion);
                        };
                        this.startHumeFaceDetection();
                    }

                    if (this.config.enableHumeVoice) {
                        await this.humeDetector.connectVoice();
                        this.humeDetector.onVoiceEmotion = (emotion) => {
                            this.updateEmotionDisplay('humeVoice', emotion);
                        };
                    }
                }

                // VAPI
                await this.initVAPI();

                // Debug
                this.elements.debugToggle.addEventListener('click', () => {
                    const canvas = this.elements.debugCanvas;
                    canvas.style.display = canvas.style.display === 'none' ? 'block' : 'none';
                });

                // Event listeners
                this.elements.button.addEventListener('click', () => {
                    if (!this.vapiInstance) return;
                    if (this.isCallActive) {
                        this.vapiInstance.stop();
                    } else {
                        this.vapiInstance.start(this.config.assistantId);
                    }
                });

                console.log('‚úÖ IORS Emotion Widget ready');
            }

            async initCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: 640, height: 480 },
                        audio: true
                    });
                    this.elements.video.srcObject = stream;
                    console.log('‚úÖ Camera ready');
                } catch (error) {
                    console.error('‚ùå Camera failed:', error);
                }
            }

            async initVAPI() {
                return new Promise((resolve) => {
                    const check = () => {
                        if (typeof window.Vapi === 'undefined') {
                            setTimeout(check, 100);
                            return;
                        }

                        this.vapiInstance = new window.Vapi(this.config.vapiPublicKey);

                        this.vapiInstance.on('call-start', () => {
                            this.isCallActive = true;
                            this.elements.status.textContent = 'S≈Çucham...';
                            this.elements.status.classList.add('active');
                            this.elements.button.classList.add('active');
                            this.elements.comparisonStats.style.display = 'block';
                        });

                        this.vapiInstance.on('call-end', () => {
                            this.isCallActive = false;
                            this.elements.status.textContent = 'Rozmowa zako≈Ñczona';
                            this.elements.status.classList.remove('active');
                            this.elements.button.classList.remove('active');
                            setTimeout(() => {
                                this.elements.status.textContent = 'Kliknij aby rozpoczƒÖƒá';
                            }, 3000);
                        });

                        console.log('‚úÖ VAPI ready');
                        resolve();
                    };
                    check();
                });
            }

            startFaceApiDetection() {
                setInterval(async () => {
                    const emotion = await this.faceApiDetector.detect();
                    if (emotion) {
                        this.updateEmotionDisplay('faceApi', emotion);
                    }
                }, this.config.detectionInterval);
            }

            startHumeFaceDetection() {
                // Capture frame and send to Hume every second
                setInterval(() => {
                    if (this.elements.video.readyState === 4) {
                        const canvas = document.createElement('canvas');
                        canvas.width = 320;
                        canvas.height = 240;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(this.elements.video, 0, 0, 320, 240);

                        // Convert to base64 and send to Hume
                        const frameData = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                        if (this.humeDetector) {
                            this.humeDetector.sendFrame(frameData);
                        }
                    }
                }, this.config.detectionInterval);
            }

            updateEmotionDisplay(source, emotion) {
                this.emotions[source] = emotion;

                let displayEl, cardEl;
                if (source === 'faceApi') {
                    displayEl = this.elements.faceApiDisplay;
                    cardEl = this.elements.faceApiCard;
                } else if (source === 'humeFace') {
                    displayEl = this.elements.humeFaceDisplay;
                    cardEl = this.elements.humeFaceCard;
                } else if (source === 'humeVoice') {
                    displayEl = this.elements.humeVoiceDisplay;
                    cardEl = this.elements.humeVoiceCard;
                }

                if (!displayEl) return;

                const emoji = EMOTION_EMOJIS[emotion.emotion] || 'üòê';
                const confidence = Math.round(emotion.confidence * 100);

                // Top emotions details
                let detailsHTML = '';
                if (emotion.all) {
                    const topEmotions = Object.entries(emotion.all)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3);

                    detailsHTML = '<div class="emotion-details">';
                    topEmotions.forEach(([em, score]) => {
                        const pct = typeof score === 'number' ? Math.round(score * 100) : score;
                        detailsHTML += `
                            <div class="emotion-details-item">
                                <span class="emotion-details-label">${em}</span>
                                <span class="emotion-details-value">${pct}%</span>
                            </div>
                        `;
                    });
                    detailsHTML += '</div>';
                }

                displayEl.innerHTML = `
                    <div class="emotion-emoji">${emoji}</div>
                    <div class="emotion-name">${emotion.emotion}</div>
                    <div class="emotion-confidence">${confidence}%</div>
                    ${detailsHTML}
                `;

                // Highlight active card
                cardEl.classList.add('active');
                setTimeout(() => cardEl.classList.remove('active'), 1000);

                // Update comparison stats
                this.updateComparisonStats();
            }

            updateComparisonStats() {
                const { faceApi, humeFace, humeVoice } = this.emotions;

                // Face-api vs Hume Face match
                if (faceApi && humeFace) {
                    const match = faceApi.emotion === humeFace.emotion;
                    document.getElementById('statFaceMatch').textContent =
                        match ? '‚úÖ Zgodne' : '‚ùå R√≥≈ºne';
                }

                // Voice vs Face (Hume)
                if (humeVoice && humeFace) {
                    const match = humeVoice.emotion === humeFace.emotion;
                    document.getElementById('statVoiceFace').textContent =
                        match ? '‚úÖ Zgodne' : '‚ùå R√≥≈ºne';
                }

                // Consensus
                const allEmotions = [faceApi, humeFace, humeVoice]
                    .filter(e => e !== null)
                    .map(e => e.emotion);

                if (allEmotions.length > 0) {
                    const counts = {};
                    allEmotions.forEach(e => {
                        counts[e] = (counts[e] || 0) + 1;
                    });
                    const consensus = Object.entries(counts)
                        .sort((a, b) => b[1] - a[1])[0][0];

                    document.getElementById('statConsensus').textContent =
                        `${EMOTION_EMOJIS[consensus] || 'üòê'} ${consensus}`;
                }
            }
        }

        // ============================================
        // INITIALIZE
        // ============================================
        window.addEventListener('load', () => {
            window.IORS = new IORSEmotionWidget(IORS_CONFIG);
        });
    </script>
</body>
</html>
